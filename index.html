<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Easy Note</title>

<link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d6efd">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta
    name="description"
    content="In a world full of noise, Easy Note, brings you only what truly matters, clearly, accurately, and without unnecessary clutter."/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
body {
  margin: 0;
  overflow: hidden;
  font-family: sans-serif;
  user-select: none;
  -webkit-user-select: none;
  background: #fdfcf8;
}

.floating-btn {
  position: fixed;
  top: 15px;
  left: 15px;
  width: 45px;
  height: 45px;
  border-radius: 50%;
  background: #e8e8e8;
  border: none;
  font-size: 20px;
  cursor: pointer;
  z-index: 10;
}

.toolbar {
  position: fixed;
  top: 70px;
  left: 15px;
  background: #e8e8e8;
  padding: 10px;
  border-radius: 10px;
  display: none;
  flex-direction: column;
  gap: 8px;
  z-index: 10;
}

canvas {
  display: block;
  touch-action: none;
}
.refresh-btn {
  margin: 10px;
  padding: 6px 12px;
  background-color: #fff;
  color: #333;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.refresh-btn:hover {
  background-color: #ddd;
}
</style>
</head>
<body>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(() => console.log("Service Worker Registered"));
    }
  </script>
<p>Use your finger or stylus to draw on the canvas. Tap the â˜° button to access tools, colors, and page options. You can save your work as an image or PDF. Enjoy your note-taking!</p>
<button class="floating-btn" onclick="toggleToolbar()">â˜°</button>

<div class="toolbar" id="toolbar">
  <select id="tool">
    <option value="pen">Pen</option>
    <option value="pencil">Pencil</option>
    <option value="highlighter">Highlighter</option>
    <option value="eraser">Eraser</option>
  </select>

  <select id="presetSize">
    <option value="2">Fine</option>
    <option value="4" selected>Medium</option>
    <option value="7">Bold</option>
  </select>

  <input type="color" id="color" value="#000000">

  <button onclick="undo()">Undo</button>
  <button onclick="redo()">Redo</button>
  <button onclick="addPage()">Add Page</button>
  <button onclick="prevPage()">â—€</button>
  <button onclick="nextPage()">â–¶</button>
  <button onclick="saveImage()">Save Image</button>
  <button onclick="savePDF()">Save PDF</button>
<button onclick="refreshPage()" class="refresh-btn">ðŸ”„ Refresh</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let ratio = window.devicePixelRatio || 1;
let drawing = false;
let currentPath = [];
let pages = [[]];
let redoStack = [[]];
let currentPage = 0;

let scale = 0.5;
let originX = 0;
let originY = 0;
let lastDistance = 0;
let isPanning = false;

/* ---------- PAPER TEXTURE ---------- */
let paperPattern;

function generatePaperTexture() {
  const textureCanvas = document.createElement("canvas");
  const size = 300;
  textureCanvas.width = size;
  textureCanvas.height = size;
  const tctx = textureCanvas.getContext("2d");

  tctx.fillStyle = "#fdfcf8";
  tctx.fillRect(0, 0, size, size);

  for (let i = 0; i < 4000; i++) {
    const x = Math.random() * size;
    const y = Math.random() * size;
    const alpha = Math.random() * 0.05;
    tctx.fillStyle = `rgba(0,0,0,${alpha})`;
    tctx.fillRect(x, y, 1, 1);
  }

  paperPattern = ctx.createPattern(textureCanvas, "repeat");
}

generatePaperTexture();

/* ---------- DPI SETUP ---------- */
function resizeCanvas() {
  const w = window.innerWidth;
  const h = window.innerHeight;

  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  canvas.width = w * ratio;
  canvas.height = h * ratio;

  redraw();
}

window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ---------- TOOLBAR ---------- */
function toggleToolbar() {
  const tb = document.getElementById("toolbar");
  tb.style.display = tb.style.display === "flex" ? "none" : "flex";
}

/* ---------- DRAWING ---------- */
function startDraw(e) {
  if (e.touches && e.touches.length > 1) return;
  drawing = true;
  canvas.setPointerCapture(e.pointerId);
  currentPath = [];
  addPoint(e);
}

function draw(e) {
  if (!drawing) return;

  addPoint(e);
  let p = currentPath[currentPath.length - 1];
  let prev = currentPath[currentPath.length - 2];
  if (!prev) return;

  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  if (tool.value === "eraser") {
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineWidth = presetSize.value * 3;
  } else {
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = color.value;

    if (tool.value === "highlighter") {
      ctx.globalAlpha = 0.25;
      ctx.lineWidth = presetSize.value * 3;
    } else if (tool.value === "pen") {
      ctx.globalAlpha = 1;
      ctx.lineWidth = presetSize.value * (0.5 + p.pressure * 1.5);
    } else if (tool.value === "pencil") {
      ctx.globalAlpha = 0.6 + p.pressure * 0.4;
      ctx.lineWidth = presetSize.value * (0.3 + p.pressure * 1.2);
    }
  }

  ctx.beginPath();
  ctx.moveTo(prev.x, prev.y);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
}

function endDraw() {
  if (!drawing) return;
  drawing = false;

  pages[currentPage].push({
    tool: tool.value,
    color: color.value,
    size: presetSize.value,
    points: [...currentPath]
  });

  redoStack[currentPage] = [];
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}

function addPoint(e) {
  const rect = canvas.getBoundingClientRect();
  let pressure = e.pressure;
  if (!pressure || pressure === 0) pressure = 0.5;

  currentPath.push({
    x: (e.clientX - rect.left - originX) / scale,
    y: (e.clientY - rect.top - originY) / scale,
    pressure: pressure
  });
}

/* ---------- REDRAW ---------- */
function redraw() {
  ctx.setTransform(ratio * scale, 0, 0, ratio * scale, originX * ratio, originY * ratio);
  ctx.clearRect(-originX, -originY, canvas.width, canvas.height);

  ctx.fillStyle = paperPattern;
  ctx.fillRect(-originX, -originY, canvas.width / ratio / scale, canvas.height / ratio / scale);

  pages[currentPage].forEach(path => {
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    for (let i = 1; i < path.points.length; i++) {
      let prev = path.points[i - 1];
      let curr = path.points[i];

      if (path.tool === "eraser") {
        ctx.globalCompositeOperation = "destination-out";
        ctx.lineWidth = path.size * 3;
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = path.color;

        if (path.tool === "highlighter") {
          ctx.globalAlpha = 0.25;
          ctx.lineWidth = path.size * 3;
        } else if (path.tool === "pen") {
          ctx.globalAlpha = 1;
          ctx.lineWidth = path.size * (0.5 + (curr.pressure || 0.5) * 1.5);
        } else if (path.tool === "pencil") {
          ctx.globalAlpha = 0.6 + (curr.pressure || 0.5) * 0.4;
          ctx.lineWidth = path.size * (0.3 + (curr.pressure || 0.5) * 1.2);
        }
      }

      ctx.beginPath();
      ctx.moveTo(prev.x, prev.y);
      ctx.lineTo(curr.x, curr.y);
      ctx.stroke();
    }
  });

  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}

/* ---------- ZOOM ---------- */
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 2) {
    drawing = false;
    isPanning = false;
  }
  if (e.touches.length === 3) {
  drawing = false;
  isPanning = false;
}
if (e.touches.length === 4) {
  drawing = false;
  isPanning = false;
}

if (e.touches.length === 5) {
  drawing = false;
  isPanning = false;
}

});

/* ---------- PAGE ---------- */
function addPage() { pages.push([]); redoStack.push([]); currentPage = pages.length - 1; redraw(); }
function prevPage() { if (currentPage > 0) { currentPage--; redraw(); } }
function nextPage() { if (currentPage < pages.length - 1) { currentPage++; redraw(); } }
function undo() { if (pages[currentPage].length) { redoStack[currentPage].push(pages[currentPage].pop()); redraw(); } }
function redo() { if (redoStack[currentPage].length) { pages[currentPage].push(redoStack[currentPage].pop()); redraw(); } }

/* ---------- EXPORT ---------- */
function saveImage() {
  const link = document.createElement("a");
  link.download = "drawing.png";
  link.href = canvas.toDataURL("image/png", 1.0);
  link.click();
}

async function savePDF() {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ unit: "px", format: [canvas.width / ratio, canvas.height / ratio] });

  pages.forEach((page, i) => {
    if (i > 0) pdf.addPage();
    const img = canvas.toDataURL("image/png", 1.0);
    pdf.addImage(img, "PNG", 0, 0, canvas.width / ratio, canvas.height / ratio);
  });

  pdf.save("drawing.pdf");
}

/* ---------- POINTER EVENTS ---------- */
canvas.addEventListener("pointerdown", startDraw);
canvas.addEventListener("pointermove", draw);
canvas.addEventListener("pointerup", endDraw);
canvas.addEventListener("pointercancel", endDraw);

</script>
<script>
function refreshPage() {
  location.reload();
}
</script>
</body>

</html>
