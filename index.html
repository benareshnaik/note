<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Easy Note</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#0d6efd">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
body {
  margin: 0;
  overflow: hidden;
  font-family: sans-serif;
  user-select: none;
  background: #fdfcf8;
}

.floating-btn {
  position: fixed;
  top: 15px;
  left: 15px;
  width: 45px;
  height: 45px;
  border-radius: 50%;
  background: #e8e8e8;
  border: none;
  font-size: 20px;
  cursor: pointer;
  z-index: 10;
}

.toolbar {
  position: fixed;
  top: 70px;
  left: 15px;
  background: #e8e8e8;
  padding: 10px;
  border-radius: 10px;
  display: none;
  flex-direction: column;
  gap: 8px;
  z-index: 10;
}

canvas {
  display: block;
  touch-action: none;
}
</style>
</head>

<body>

<button class="floating-btn" onclick="toggleToolbar()">☰</button>

<div class="toolbar" id="toolbar">
  <select id="tool">
    <option value="pen">Pen</option>
    <option value="pencil">Pencil</option>
    <option value="highlighter">Highlighter</option>
    <option value="eraser">Eraser</option>
  </select>

  <select id="presetSize">
    <option value="2">Fine</option>
    <option value="4" selected>Medium</option>
    <option value="7">Bold</option>
  </select>

  <input type="color" id="color" value="#000000">

  <button onclick="undo()">Undo</button>
  <button onclick="redo()">Redo</button>
  <button onclick="addPage()">Add Page</button>
  <button onclick="prevPage()">◀</button>
  <button onclick="nextPage()">▶</button>
  <button onclick="saveImage()">Save Image</button>
  <button onclick="savePDF()">Save PDF</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";

let ratio = window.devicePixelRatio || 1;
let drawing = false;
let currentPath = [];
let pages = [[]];
let redoStack = [[]];
let currentPage = 0;

let scale = 1;
let originX = 0;
let originY = 0;

/* ---------- PAPER TEXTURE ---------- */
let paperPattern;

function generatePaperTexture() {
  const textureCanvas = document.createElement("canvas");
  const size = 300;
  textureCanvas.width = size;
  textureCanvas.height = size;
  const tctx = textureCanvas.getContext("2d");

  tctx.fillStyle = "#fdfcf8";
  tctx.fillRect(0, 0, size, size);

  for (let i = 0; i < 4000; i++) {
    const x = Math.random() * size;
    const y = Math.random() * size;
    const alpha = Math.random() * 0.05;
    tctx.fillStyle = `rgba(0,0,0,${alpha})`;
    tctx.fillRect(x, y, 1, 1);
  }

  paperPattern = ctx.createPattern(textureCanvas, "repeat");
}

generatePaperTexture();

/* ---------- DPI SETUP ---------- */
function resizeCanvas() {
  const w = window.innerWidth;
  const h = window.innerHeight;

  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  canvas.width = w * ratio;
  canvas.height = h * ratio;

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(ratio, ratio);

  redraw();
}

window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ---------- TOOLBAR ---------- */
function toggleToolbar() {
  const tb = document.getElementById("toolbar");
  tb.style.display = tb.style.display === "flex" ? "none" : "flex";
}

/* ---------- ADD POINT WITH JITTER FILTER ---------- */
function addPoint(e) {
  const rect = canvas.getBoundingClientRect();

  let x = (e.clientX - rect.left - originX) / scale;
  let y = (e.clientY - rect.top - originY) / scale;

  let pressure = e.pressure;
  if (!pressure || pressure === 0) pressure = 0.5;

  if (currentPath.length > 0) {
    const last = currentPath[currentPath.length - 1];
    const dx = last.x - x;
    const dy = last.y - y;
    if (dx * dx + dy * dy < 0.3) return;
  }

  currentPath.push({ x, y, pressure });
}

/* ---------- DRAW ---------- */
function startDraw(e) {
  drawing = true;
  currentPath = [];
  addPoint(e);
}

function draw(e) {
  if (!drawing) return;

  const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];

  for (let ev of events) {
    addPoint(ev);

    if (currentPath.length < 2) continue;

    const p1 = currentPath[currentPath.length - 2];
    const p2 = currentPath[currentPath.length - 1];

    const midX = (p1.x + p2.x) / 2;
    const midY = (p1.y + p2.y) / 2;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    if (tool.value === "eraser") {
      ctx.globalCompositeOperation = "destination-out";
      ctx.lineWidth = presetSize.value * 3;
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = color.value;

      if (tool.value === "highlighter") {
        ctx.globalAlpha = 0.25;
        ctx.lineWidth = presetSize.value * 3;
      } else if (tool.value === "pen") {
        ctx.globalAlpha = 1;
        ctx.lineWidth = Math.max(
          0.5,
          presetSize.value * (0.5 + p2.pressure * 1.5)
        );
      } else if (tool.value === "pencil") {
        ctx.globalAlpha = 0.6 + p2.pressure * 0.4;
        ctx.lineWidth = Math.max(
          0.3,
          presetSize.value * (0.3 + p2.pressure * 1.2)
        );
      }
    }

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
    ctx.stroke();
  }
}

function endDraw() {
  if (!drawing) return;
  drawing = false;

  pages[currentPage].push({
    tool: tool.value,
    color: color.value,
    size: presetSize.value,
    points: [...currentPath]
  });

  redoStack[currentPage] = [];
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}

/* ---------- REDRAW ---------- */
function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.scale(ratio, ratio);

  ctx.fillStyle = paperPattern;
  ctx.fillRect(0, 0, canvas.width / ratio, canvas.height / ratio);

  pages[currentPage].forEach(path => {
    for (let i = 1; i < path.points.length; i++) {
      const p1 = path.points[i - 1];
      const p2 = path.points[i];

      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      if (path.tool === "eraser") {
        ctx.globalCompositeOperation = "destination-out";
        ctx.lineWidth = path.size * 3;
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = path.color;

        if (path.tool === "highlighter") {
          ctx.globalAlpha = 0.25;
          ctx.lineWidth = path.size * 3;
        } else if (path.tool === "pen") {
          ctx.globalAlpha = 1;
          ctx.lineWidth = Math.max(
            0.5,
            path.size * (0.5 + (p2.pressure || 0.5) * 1.5)
          );
        } else if (path.tool === "pencil") {
          ctx.globalAlpha = 0.6 + (p2.pressure || 0.5) * 0.4;
          ctx.lineWidth = Math.max(
            0.3,
            path.size * (0.3 + (p2.pressure || 0.5) * 1.2)
          );
        }
      }

      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
      ctx.stroke();
    }
  });

  ctx.restore();
}

/* ---------- PAGE CONTROLS ---------- */
function addPage() { pages.push([]); redoStack.push([]); currentPage = pages.length - 1; redraw(); }
function prevPage() { if (currentPage > 0) { currentPage--; redraw(); } }
function nextPage() { if (currentPage < pages.length - 1) { currentPage++; redraw(); } }
function undo() { if (pages[currentPage].length) { redoStack[currentPage].push(pages[currentPage].pop()); redraw(); } }
function redo() { if (redoStack[currentPage].length) { pages[currentPage].push(redoStack[currentPage].pop()); redraw(); } }

/* ---------- EXPORT ---------- */
function saveImage() {
  const link = document.createElement("a");
  link.download = "drawing.png";
  link.href = canvas.toDataURL("image/png", 1.0);
  link.click();
}

async function savePDF() {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ unit: "px", format: [canvas.width / ratio, canvas.height / ratio] });
  const img = canvas.toDataURL("image/png", 1.0);
  pdf.addImage(img, "PNG", 0, 0, canvas.width / ratio, canvas.height / ratio);
  pdf.save("drawing.pdf");
}

/* ---------- POINTER EVENTS ---------- */
canvas.addEventListener("pointerdown", startDraw);
canvas.addEventListener("pointermove", draw);
canvas.addEventListener("pointerup", endDraw);
canvas.addEventListener("pointercancel", endDraw);

</script>

</body>
</html>